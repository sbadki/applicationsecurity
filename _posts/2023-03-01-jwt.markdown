---
layout: post
title:  "JSON Web Token"
date:   2023-03-01 09:00:00 +0800
categories: Application security blogs
---

## What is JSON Web Token? ##

*JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties 
as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm)
or a public/private key pair using RSA or ECDSA.*

Here, securely transmitting means the data can't be tampered with, as its digitally signed. Optionally the data can also be encrypted. In simple terms if
JWT is not encrypted but encoded its referred as JWS(Jason Web Signature) and when its encrypted its referred as (Jason Web Encryption)


## What is the JSON Web Token structure? ##


JSON Web Tokens consist of three parts which are separated by dots (.)

1. Header
2. Payload and
3. Signature

Both header and payload are represented by a JSON object.

The **header** describes the cryptographic operations applied to the JWT with other optional properties. Typically we use "Typ" - Type of the token which
is always JWT, and "alg" - The algorithm which would be used to sign the JSON Web Token. There are various algorithm to specify but mostly common once 
are HS256 and RS256.

HS256 - HMAC SHA256 (symmetrical algorithm - server and client uses same secret to sign and verify the token respectively)
RS256 - RSASSA-PKCS1-v1_5 with the SHA-256 hash (asymmetrical algorithm - uses private and public key pair to sign and verify the token at server and 
client side respectively)

The **payload** represents a JSON object, it consists of claims conveyed by the JWT which is typically used by the server to verify that the user has 
permission to perform the action they are requesting.

There are a set of standard key/value pairs that are defined as part of JWT payload, few common once are
• Sub (Subject): Identifies the user making the request and being authenticated.
• Iss (Issuer): The server that issued the token.
• Aud (Audience): Provides some form of identification of the recipient of this token.
• Iat(Issued at) : Time when the token is issued by the server.
• Exp (Expiration date): Tokens usually don’t last forever. Exp ensures that whoever is using the token provides a recently generated token


The **Signature** is used to verify that the issuer of the JWT is who it is and to ensure that the messages wasn't changed along the way.

    Signature = HMACSHA256(
                base64UrlEncode(header) + "." +
                base64UrlEncode(payload),
                secret)


So finally, JSON web token  = encoded header + "." + encoded payload + "."  +encoded signature


![encodedjwt]({{ "/assets/images/jwt/fig1-encodedjwt.png" | relative_url }})


If we Decode it we could see the JSON object for Header, Payload with the secret to verify the signature. Data passed in header or payload is in plain 
text, so it's not good idea to pass any sensitive information in those section.


![jwtstructure]({{ "/assets/images/jwt/fig2-jwtstructure.png" | relative_url }})


Above token is signed using HS256, which is self-contained, it has all the information needed for its validation.

More details can be found on:  https://jwt.io/introduction/


## Where do we use JWT? ##

JWT is used in many places like for authentication, authorization and session management. It's useful for API authentication and server to server 
authorization. 
Many security specialist doesn't suggest JWT as session tokens. 

Refer https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid for more details.


## JWT in action with example ##

We have taken an example of client-server communication and how it's benefited by using JSON token.
User roles are specified as "USER, ADMIN and MODERATOR", based on the Role, user is entitled to perform certain action.

	1. Registering user by passing required information. 
	2. Authenticating user by passing username and password, if successful JWT signed with secret is passed in the response
	3. For every other request, user attaches JWT token in the Authorization header and send it to server. User doesn’t need to provide authentication on every request. 
	4. Sever validates JWT and based on claims specified in the JWT token user can access the resource.
	5. If the Token is tampered or if user doesn't have required permission to access the resource then 401: Unauthorized error would be thrown.


![jwtstructure]({{ "/assets/images/jwt/fig3-appflow.png" | relative_url }})


## What are disadvantages of JWT ##

1. JWTs are not revocable. JWT' are valid until its expiry time. To overcome this if we keep a track of blacklisted token in a DB then we need to verify
the token against the list and check. 
So the whole purpose of stateless JWT would be of no use.
2. If developers fail to validate the signature at server end then attacker can simply modify the JWT and pass the "algo": "none" in JWT header and strip
off the signature all together.
3. If the JWTs are stored in cookies then CSRF may takes place, we would still need to protect from it. 
4. IF the JWTs are stored in local storage, we would prevent it from CSRF but then XSS attacks might take place. 
5. The JWT digitally signed with secret and if that secret is stolen then the JWT will be compromised.
6. Over the period of time, developer tends to put many data into the payload which makes JWT heavy if it's stored in cookie. Cookie has a limitation to 
hold the data. 


## PART 1 : What is Jason Web Token Exploits and its Mitigation? ##


Here I'll be taking an examples from PortSwigger. Main goal is not to provide complete solution for the PortSwigger labs but to access the Admin portal 
by logging in as admin user by exploiting JWT in various ways. 

We will be using JWT extension provided by Burp for exploiting vulnerabilities.

### 1. JWT Authentication bypass via unverified signature ### 


This happens when applications fail to perform the JWT validation properly at server end. In this case attacker can modify the payload in JWT token and 
access the resource.
1. Login with the credentials' wiener : peter
2. Intercept GET /my-account request, we would see the JWT is token is passed in cookie.
3. Select the payload, and decode it to Base64, we would see its content as:
{
	"iss":"portswigger",
	"sub":"wiener",
	"exp": 167764130
}
4. Modify the "sub":"administrator" under the Inspector section in burp suit, and click on apply changes.

![exploit1payload]({{ "/assets/images/jwt/fig4-exploit1payload.png" | relative_url }})

5. Modify GET request to access /admin request and send
6. By altering the payload we are able to access the admin portal.

![exploit1result]({{ "/assets/images/jwt/fig5-exploit1result.png" | relative_url }})

7. We can look for the /delete api and access that api to delete any user. 

**Mitigation:** Application must verify the signature of the token whether It's valid or not?

### 2. Accept token with no signature ###

JWT supports different types of algorithms to generate a signature, to name a few RSA, HMAC, Eliptic Curve, None etc

When "algo":"none" is specified that means token is not signed. With the help of this attacker a bypass signature by changing the value of alg to none 
and stripping of signature from the JWT.

By altering the header with alg: none,  we are able to access the admin portal.

1. Login with the credentials' wiener : peter
2. Intercept GET /my-account request, we would see the JWT is token is passed in cookie.
3. Select the header, and decode it to Base64, we would see its content as:
{
    "kid":"89d3e87c-f161-420d-bf53-a7c990f52248",
    "alg": "RS256"
}
4. Modify the "alg":"none" under the Inspector section in burp suit, and click on apply changes. Strip off the signature section completely from the JWT 
keeping trailing dot (.) as is,

![exploit2payload]({{ "/assets/images/jwt/fig6-exploit2payload.png" | relative_url }})

5. Modify GET request to access /admin request and send
6. By modifying the algo we are able to access the admin portal.

![exploit2result]({{ "/assets/images/jwt/fig7-exploit2result.png" | relative_url }})

7. We can look for the /delete api and access that api to delete any user. 


**Mitigation:** Application must verify the token for algo specified in the token is same as the one used while creating it.

### 3. Brute forcing secret ###

If server uses weak secret to sign the JWT then it's very easy to bruit force it and re-create the JWT with the signature. Bruit forcing for a secret is 
easier with the help of Hashcat utility.

**Hashcat Utility:**
Hashcat needs 1. Valid JWT and 2. List of known hash passwords. It signs the Header and payload from the JWT we pass in the command with the secret 
available in the known hashed password list.Then it compares the resulting signature with the original one from the server. if any of the signature 
matches, Hashcat shows the identified secret in the format:

hashcat -a 0 -m 16500 <JWT> <list_of_known_password>

Attacker can modify the malicious JWT and re-sign it with the secret he got it from bruit forcing.

1. Login with the credentials' wiener : peter
2. Intercept GET /my-account request, we would see the JWT is token is passed in cookie.
3. Check the header, and decode it to Base64, we would see the algorithm used is HS256, which is shared secret so attacker might try to brute force the
secret using Hashcat utility. 
{
    "kid":"89d3e87c-f161-420d-bf53-a7c990f52248",
    "alg": "HS256"
}
4. Brute force secret using HashCat utility. This will give the secret.

![exploit2result]({{ "/assets/images/jwt/fig8a-hashcatresult.png" | relative_url }})

5. Will create a symmetric key and sign it with the secret we got via bruteforce.

6. Modify GET request to access /admin request. Update payload "sub" change to "administrator" and sign the token with the key created in above step.

![exploit2payload]({{ "/assets/images/jwt/fig6-exploit2payload.png" | relative_url }})

![exploit2result]({{ "/assets/images/jwt/fig7-exploit2result.png" | relative_url }})

7. We can look for the /delete api and access that api to delete any user. 


**Mitigation:** Application should use the strong password and must keep in the secret manager for more security.


### 4. JWT Algo confusion ### 

Here the application does not check whether the algorithm of the received token matches the expected algorithm because of which algorithm confusion arises.
JWT accepts both symmetric and asymmetric encryption algorithms. Depending on the encryption type, we need to use either a shared secret or a 
public-private key pair.

If application is using an asymmetric encryption, it can openly publish its public key and keep the private key secret. This allows the application to 
sign tokens using its private key and anyone can verify this token using its public key.

1. Login with the credentials' wiener : peter
2. Intercept GET /my-account request, we would see the JWT is token is passed in cookie.
3. Check the header, and decode it to Base64, we would see the algorithm used is RS256.
{
	"kid":"a4c40a9e-fd27-4e29-81c6-2f9a2d592cd2",
	"alg": "RS256"
}
4. We created malicious key using servers public key and sign the token using that malicious key. 
5. Modify the JWT and update the header "alg": "HS256"

![exploit5result]({{ "/assets/images/jwt/fig13-exploit5result.png" | relative_url }})


**Mitigation:** Application should use modern validation library where in it should perform robust signature verification on JWT. Should always check 
whether the algo specified in the token is same as the one used while creating it.


## References: ##

_https://www.rfc-editor.org/rfc/rfc7519

_https://portswigger.net/web-security/jwt

_https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html

_http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/

Github repo: https://github.com/sbadki/applicationsecurity/tree/main/springboot-jwt-example

---