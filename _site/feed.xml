<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/applicationsecurity/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/applicationsecurity/" rel="alternate" type="text/html" /><updated>2023-02-22T18:51:57+08:00</updated><id>http://localhost:4000/applicationsecurity/feed.xml</id><title type="html">Application Security Blog</title><subtitle>Blog posts on Application security using GitHub Pages.</subtitle><entry><title type="html">Rate Limiting API endpoints with Bucket4j</title><link href="http://localhost:4000/applicationsecurity/posts/2023-01-31-ratelimiting.html" rel="alternate" type="text/html" title="Rate Limiting API endpoints with Bucket4j" /><published>2023-01-31T01:23:45+08:00</published><updated>2023-01-31T01:23:45+08:00</updated><id>http://localhost:4000/applicationsecurity/posts/ratelimiting</id><content type="html" xml:base="http://localhost:4000/applicationsecurity/posts/2023-01-31-ratelimiting.html">&lt;h2 id=&quot;rate-limiting&quot;&gt;Rate Limiting&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rate limiting&lt;/strong&gt; is a strategy for limiting network traffic. It restricts client for making number of API calls within 
a certain time frame. This is required to prevent Brute force, DoS or DDos, web scraping attacks.&lt;/p&gt;

&lt;p&gt;Rate limits can be applied based on tracking IP address, API keys or access tokens to an API. If we apply rate limit
based on IP Addresses, A rate limiting solution measures the amount of time between each request from each IP address,
and also measures the number of requests within a specified timeframe. If there are too many requests from a single IP
within the given timeframe, the rate limiting solution will not fulfil the IP address’s requests for a certain amount
of time.&lt;/p&gt;

&lt;p&gt;So what happens to the requests if it reaches the limit.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They may be dropped/rejected for sending Too many requests - HTTP 429.&lt;/li&gt;
  &lt;li&gt;They may be queued until the remaining time period is elapsed.&lt;/li&gt;
  &lt;li&gt;They may be transmitted by charging for an extra requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;token-bucket-algorithm&quot;&gt;Token bucket Algorithm&lt;/h2&gt;

&lt;p&gt;Consider there is a bucket which can hold n number of tokens, whose capacity is predefined. So, whenever any client 
request an API endpoint he needs to get a token from the bucket so that the request is successful. What if there is no 
token available in the bucket then the client’s request will be rejected to progress further.&lt;/p&gt;

&lt;p&gt;While making this request, the tokens are being consumed by it. Simultaneously the bucket is re-filling the tokens at 
fixed rate making sure the capacity of the bucket won’t exceed at any given point of time.&lt;/p&gt;

&lt;p&gt;Before implementing token-bucket algorithm, will understand some terminologies used in algorithm.&lt;/p&gt;

&lt;h2 id=&quot;terminologies-user-in-algorithm&quot;&gt;Terminologies User in Algorithm:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Bucket&lt;/strong&gt; - consider it is a container&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Limitations that are used by bucket can be denoted in terms of bandwidths. Bandwidth is denoted by the following terms:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capacity&lt;/strong&gt; - specifies how many tokens your bucket has.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Refill&lt;/strong&gt; - specifies how fast tokens can be refilled after it was consumed from a bucket.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Greedy - This type of refill greedily regenerates tokens manner, it tries to add the tokens to the bucket as soon as possible.
Refill.greedy(10, Duration.ofSeconds(1));

- Interval - This type of refill regenerates tokens in an interval manner. &quot;Interval&quot; in opposite to &quot;greedy&quot; will wait until the whole period will be elapsed before regenerating the whole amount of tokens.
Refill.intervally(100, Duration.ofMinutes(1));

- IntervallyAligned - In addition to Interval it is possible to specify the time when the first refill should happen. This type can be used to configure clear interval boundary i.e. start of the second, minute, hour, day. 

InstantfirstRefillTime=ZonedDateTime.now()
		.truncatedTo(ChronoUnit.HOURS)
		.plus(1,ChronoUnit.HOURS)
		.toInstant();
	
Bandwidth.classic(400,Refill.intervallyAligned(400,Duration.ofHours(1),firstRefillTime,true));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Initial tokens&lt;/strong&gt; - Bucket4j extends the token-bucket algorithm by allowing to specify the initial amount of tokens for 
each bandwidth. By default, an initial amount of tokens equals to capacity and can be changed by withInitialTokens method.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example:&lt;/h2&gt;

&lt;p&gt;It’s a simple Spring boot application which has UserController with three endpoints createUser, getUser and get all users. 
Rate limit is applied to all three endpoints and will see it in action.  The code can be referred from the&lt;/p&gt;

&lt;p&gt;_Github repo: https://github.com/sbadki/applicationsecurity/tree/main&lt;/p&gt;

&lt;p&gt;We are using Bucket4J, it’s a java library to implement the rate limiting which is based of token-bucket algorithm.
Provide following dependency with other required dependencies for spring boot rest API.&lt;/p&gt;

&lt;p&gt;Let’s take an example, if rate limit is set to 10 requests per minute for an API. That means the capacity of the bucket
can set to 10, and we can refill it with 10 tokens per minute.&lt;/p&gt;

&lt;p&gt;If we receive 8 request for first minute, which is less than the bucket capacity for a minute. Then the remaining 2
tokens will be carry forward to next minute in addition to 8 new tokens to full-fill the capacity of bucket to 10 tokens.&lt;/p&gt;

&lt;p&gt;If we receive 10 requests in first 45 seconds itself, then we would need to wait another 15 seconds to serve the requests.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/images/ratelimit/dependency.JPG&quot; alt=&quot;dependency.JPG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Bucket is built with rate limit of 10 requests per minute, So the API will reject the requests if its already received 
10 requests in a time frame of 1 minute.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/images/ratelimit/bucket_greedy.JPG&quot; alt=&quot;bucket_greedy.JPG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But what if all the 10 requests came in first 5 seconds which consumed all the tokens leads to spike in the application
suddenly.We can control this limit by applying multiple limits to the bucket. The bucket would serve 10 requests per 
minute but serve 5 requests in 20 seconds time window.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/images/ratelimit/bucket_inter.JPG&quot; alt=&quot;bucket_inter.JPG&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation:&lt;/h2&gt;

&lt;p&gt;tryConsume will Tries to consume specified number of tokens from the bucket during the specified timeframe.
When it exceeds rate limit then it will reject the request with status code as HTTP - 429 TooManyRequests.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/images/ratelimit/api_ratelimits.JPG&quot; alt=&quot;api_ratelimits.JPG&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;result&quot;&gt;Result:&lt;/h2&gt;

&lt;p&gt;All the requests after 5 seconds got rejected.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/images/ratelimit/result.JPG&quot; alt=&quot;result.JPG&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Rate Limiting</summary></entry><entry><title type="html">Insecure Deserialization</title><link href="http://localhost:4000/applicationsecurity/posts/2023-01-30-insecure-deserialization.html" rel="alternate" type="text/html" title="Insecure Deserialization" /><published>2023-01-30T12:28:45+08:00</published><updated>2023-01-30T12:28:45+08:00</updated><id>http://localhost:4000/applicationsecurity/posts/insecure-deserialization</id><content type="html" xml:base="http://localhost:4000/applicationsecurity/posts/2023-01-30-insecure-deserialization.html">&lt;p&gt;&lt;strong&gt;Insecure deserialization&lt;/strong&gt; is one of the top vulnerability in OWASP top 10 list for 2021. Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application. Successful insecure deserialization attacks could allow an attacker to carry out denial-of-service (DoS) attacks, authentication bypasses and remote code execution attacks.&lt;/p&gt;

&lt;h2 id=&quot;what-is-serialization--deserialization&quot;&gt;What is Serialization &amp;amp; Deserialization?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Serialization&lt;/strong&gt; refers to a process of converting an object into a format which can be persisted to disk (for example saved to a file or a datastore), sent through streams (for example stdout), or sent over a network. The format in which an object is serialized into, can either be binary or structured text (for example XML, JSON YAML…). JSON and XML are two of the most used serialization formats within web applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deserialization&lt;/strong&gt; on the other hand, is the opposite of serialization, that is, transforming serialized data coming from a file, stream or network socket into an object.
There are different libraries or classes for different languages for serialization/deserialization purposes such as in 
Python - Pickle,
PHP - Serialize/Unserialize,
Java - ObjectInputStream/ObjectOutputStream and in
JavaScript - JSON.stringfy()/JSON.parse()&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/serialization.png&quot; alt=&quot;Portswigger&quot; /&gt;
_Photo by: [Portswigger.net]&lt;/p&gt;

&lt;p&gt;Many programming languages support the serialization and deserialization of objects, including Java, PHP, Python, and Ruby. It’s important to understand that safe deserialization of objects is normal practice in software development. The trouble however, starts when deserializing untrusted user input&lt;/p&gt;

&lt;h2 id=&quot;what-is-in-secure-deserialization&quot;&gt;What is In-Secure deserialization?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Insecure deserialization&lt;/strong&gt; is a type of vulnerability that arises when an attacker can manipulate the serialized object and pass harmful data into the application code which cause unintended consequences in the program’s flow.&lt;/p&gt;

&lt;p&gt;Example: We serialized an Employee object by implementing Serializable interface.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/employee.png&quot; alt=&quot;JavaExample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hex dump of the serialized employee object&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/hexdump.png&quot; alt=&quot;HexDump&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here we serialized Vulnerable Object and deserialized it, so whatever command we have passed to Vulnerable Object got executed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/vulnerable.png&quot; alt=&quot;Vulnerable&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The point to make here is that, while deserialization the application is not verifying whether the input for deserialization is the one which we expect to deserialize? It’s just deserializing whatever is being passed. With Vulnerable object we passed the command as calc.exe and it’s just executed. What if the hacker pass some arbitrary code which may give a remote access to the hacker. Certainty its possible. That’s why it’s called as insecure deserialization.&lt;/p&gt;

&lt;h2 id=&quot;what-is-happening-behind-the-scene&quot;&gt;What is happening behind the scene?&lt;/h2&gt;

&lt;p&gt;This is because Deserialization doesn’t call constructor while re-creating an object from Stream of Bytes, it is using reflection to re-create an object. All the magic is happing because we can override the readObject method. This is the method which is provided by the Serialization mechanism. These methods are also called as magic methods. Magic methods are a special subset of methods that you do not have to explicitly invoke. Instead, they are invoked automatically whenever a particular event or scenario occurs. Magic methods are a common feature of object-oriented programming in various languages like Ruby, PHP, python, Java etc.
So, this concludes that the De-Serialization is not secured. Attackers can customize deserialization protocol by overriding the readObject() function of the Java.&lt;/p&gt;

&lt;h2 id=&quot;insecure-deserialization-in-action&quot;&gt;Insecure Deserialization in action.&lt;/h2&gt;

&lt;p&gt;We take an example from Webgoat. It’s the deliberately insecure java-based application. Which has OWASP top 10 challenges.
e.g. “Try to change this serialized object in order to delay the page response for exactly 5 seconds.”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/webgoateg.png&quot; alt=&quot;webgoateg&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We need to know whether there is any object which is getting serialized and deserialized. From the page it looks like it does as the string shown is starting with r00.&lt;/li&gt;
  &lt;li&gt;Intercept the request in Burp Suite and see what’s getting pass in input field. Token=deserialize.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/inspect.png&quot; alt=&quot;inspect&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Search for any magic methods like read Object() of ObjectInputStream. It’s used by InsecureDeserializationTask. Its taking a token value from an input field directly without sanitizing it and deserializing it.&lt;/li&gt;
  &lt;li&gt;VulnerableTaskHolder Object is serializable object which is overriding readObject method which is executing command via.
   Process p = Runtime.getRuntime().exec(taskAction);
   taskAction is any string passed to its constructor. That means we can make use of this class to pass any command as string and serialized that object to execute remote code execution.&lt;/li&gt;
  &lt;li&gt;Create a test class which is serializing a VulnerableTaskHolder object by passing the taskName and taskAction as “TASK” and “Sleep 5” respectively which will delay the response of the page by 5 seconds.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/attack.png&quot; alt=&quot;attack&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;And this is how we are able to delay the page by 5 seconds.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/webgoatsuccess.png&quot; alt=&quot;webgoatsuccess&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-is-gadgets-and-chains&quot;&gt;What is Gadgets and Chains?&lt;/h2&gt;

&lt;p&gt;A gadget—as used by Lawrence &amp;amp; Frohoff in their talk Marschalling Pickle at AppSecCali 2015—is a class or function that exists in the application which helps attacker to achieve a particular goal but a gadget may not by itself do anything harmful with user input.
The exploitation strategy is to start with a “kick-off” gadget that’s executed after deserialization and build a chain of instances and method invocations to get to a “sink” gadget that’s able to execute arbitrary code or commands. Once attackers manage to get input to a sink gadget, they can do the maximum damage by performing an arbitrary code execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/gadgetchain.png&quot; alt=&quot;gadgetchain&quot; /&gt;&lt;/p&gt;

&lt;p&gt;_Photo_by: https://brandur.org/fragments/gadgets-and-chains&lt;/p&gt;

&lt;p&gt;Attacker needs access to the source code to identify such Gadgets and it’s a tedious task to do it manually. Fortunately, There are tools like “ysoserial” and “gadget insepctor” which helps us to identify such Gadgets.&lt;/p&gt;

&lt;h2 id=&quot;what-is-ysoserial-and-how-to-test-with-it&quot;&gt;What is ysoserial and how to test with it?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;ysoserial&lt;/strong&gt; is a tool for generating payloads that exploit unsafe Java object deserialization.&lt;/p&gt;

&lt;p&gt;We could see all these java libraries has gadget chains and if any of these library is happen to found in our applications classpath our application is vulnerable to Insecure deserialization vulnerability. So, today will take an example of commons-collections library and try to run arbitrary command.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/ysoserial.png&quot; alt=&quot;Ysoserial&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Usage: java -jar ysoserial.jar [payload] ‘[command]’”&lt;/p&gt;

&lt;p&gt;The command will create a payload.ser file which we deserialize it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;java.exe -jar ysoserial-all.jar CommonsCollections4 ‘calc.exe’ &amp;gt; payload.ser&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With the help of ysoserial tool we created a payload and when we deserialized that payload the command got executed. Likewise any remote code execution is possible if such classes are happened to found in our applications class path. Which is very dangerous. We might think that why anybody would keep such classes in our class path but many libraries like apache-commons, spring framework uses such classes. So it’s always advisable that we keep our application dependencies updated with latest libraries.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/gadgettest.png&quot; alt=&quot;GadgetChainTest&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-are-the-mitigations-we-can-apply&quot;&gt;What are the mitigations we can apply?&lt;/h2&gt;

&lt;p&gt;•	If possible, try to avoid serialization, instead use data formats like JSON or XML if there is no language constraints.
•	If Serialization can’t avoid and we are forced to implement Serialization due to their hierarchy. We can override deserialize method by throwing an exception.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/override.png&quot; alt=&quot;Overiride&quot; /&gt;&lt;/p&gt;

&lt;p&gt;•	Do not accept serialized object from untrusted sources. Implement a check to prevent from tampering of an object by implementing check against the whitelist.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/lookahead.png&quot; alt=&quot;Lookahead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/applicationsecurity/assets/images/insecure-deserialization/safeuse.png&quot; alt=&quot;Safeuse&quot; /&gt;&lt;/p&gt;

&lt;p&gt;•	Sanitize user inputs which helps in reduce attack surface of an application. Attackers can use objects like cookies to insert malicious information to change user roles. In some cases, they can elevate their privileges to administrator rights by using a pre-existing or cached password hash from a previous session to launch DDOS, remote execution attacks.&lt;/p&gt;

&lt;p&gt;At last, this vulnerability is very dangerous if we do not implement any mitigation in our application and it’s very difficult to overcome this vulnerability completely. So, the best practice is to apply rule suggested by OWASP team. They have provided mitigation for this vulnerability in various languages.  OWASP Insecure Deserialization Cheat Sheet for more details.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References:&lt;/h2&gt;

&lt;p&gt;_https://github.com/frohoff/ysoserial
_https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
_https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
_https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/&lt;/p&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="Application" /><category term="security" /><category term="blogs" /><summary type="html">Insecure deserialization is one of the top vulnerability in OWASP top 10 list for 2021. Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application. Successful insecure deserialization attacks could allow an attacker to carry out denial-of-service (DoS) attacks, authentication bypasses and remote code execution attacks.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/applicationsecurity/posts/2022-02-10-welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2022-02-10T01:03:13+08:00</published><updated>2022-02-10T01:03:13+08:00</updated><id>http://localhost:4000/applicationsecurity/posts/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/applicationsecurity/posts/2022-02-10-welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &apos;Hi, Tom&apos; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>