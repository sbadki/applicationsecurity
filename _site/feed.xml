<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-09T10:20:27+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Application Security Blogs</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Rate Limiting API endpoints with Bucket4j</title><link href="http://localhost:4000/2023/01/31/ratelimiting.html" rel="alternate" type="text/html" title="Rate Limiting API endpoints with Bucket4j" /><published>2023-01-31T01:23:45+08:00</published><updated>2023-01-31T01:23:45+08:00</updated><id>http://localhost:4000/2023/01/31/ratelimiting</id><content type="html" xml:base="http://localhost:4000/2023/01/31/ratelimiting.html">&lt;h2 id=&quot;rate-limiting&quot;&gt;Rate Limiting&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rate limiting&lt;/strong&gt; is a strategy for limiting network traffic. It restricts client for making number of API calls within 
a certain time frame. This is required to prevent Brute force, DoS or DDos, web scraping attacks.&lt;/p&gt;

&lt;p&gt;Rate limits can be applied based on tracking IP address, API keys or access tokens to an API. If we apply rate limit
based on IP Addresses, A rate limiting solution measures the amount of time between each request from each IP address,
and also measures the number of requests within a specified timeframe. If there are too many requests from a single IP
within the given timeframe, the rate limiting solution will not fulfil the IP address’s requests for a certain amount
of time.&lt;/p&gt;

&lt;p&gt;So what happens to the requests if it reaches the limit.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They may be dropped/rejected for sending Too many requests - HTTP 429.&lt;/li&gt;
  &lt;li&gt;They may be queued until the remaining time period is elapsed.&lt;/li&gt;
  &lt;li&gt;They may be transmitted by charging for an extra requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;token-bucket-algorithm&quot;&gt;Token bucket Algorithm&lt;/h2&gt;

&lt;p&gt;Consider there is a bucket which can hold n number of tokens, whose capacity is predefined. So, whenever any client 
request an API endpoint he needs to get a token from the bucket so that the request is successful. What if there is no 
token available in the bucket then the client’s request will be rejected to progress further.&lt;/p&gt;

&lt;p&gt;While making this request, the tokens are being consumed by it. Simultaneously the bucket is re-filling the tokens at 
fixed rate making sure the capacity of the bucket won’t exceed at any given point of time.&lt;/p&gt;

&lt;p&gt;Before implementing token-bucket algorithm, will understand some terminologies used in algorithm.&lt;/p&gt;

&lt;h2 id=&quot;terminologies-user-in-algorithm&quot;&gt;Terminologies User in Algorithm:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Bucket&lt;/strong&gt; - consider it is a container&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Limitations that are used by bucket can be denoted in terms of bandwidths. Bandwidth is denoted by the following terms:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capacity&lt;/strong&gt; - specifies how many tokens your bucket has.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Refill&lt;/strong&gt; - specifies how fast tokens can be refilled after it was consumed from a bucket.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Greedy - This type of refill greedily regenerates tokens manner, it tries to add the tokens to the bucket as soon as possible.
Refill.greedy(10, Duration.ofSeconds(1));

- Interval - This type of refill regenerates tokens in an interval manner. &quot;Interval&quot; in opposite to &quot;greedy&quot; will wait until the whole period will be elapsed before regenerating the whole amount of tokens.
Refill.intervally(100, Duration.ofMinutes(1));

- IntervallyAligned - In addition to Interval it is possible to specify the time when the first refill should happen. This type can be used to configure clear interval boundary i.e. start of the second, minute, hour, day. 

InstantfirstRefillTime=ZonedDateTime.now()
		.truncatedTo(ChronoUnit.HOURS)
		.plus(1,ChronoUnit.HOURS)
		.toInstant();
	
Bandwidth.classic(400,Refill.intervallyAligned(400,Duration.ofHours(1),firstRefillTime,true));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Initial tokens&lt;/strong&gt; - Bucket4j extends the token-bucket algorithm by allowing to specify the initial amount of tokens for 
each bandwidth. By default, an initial amount of tokens equals to capacity and can be changed by withInitialTokens method.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example:&lt;/h2&gt;

&lt;p&gt;It’s a simple Spring boot application which has UserController with three endpoints createUser, getUser and get all users. 
Rate limit is applied to all three endpoints and will see it in action.  The code can be referred from the 
Github repo: https://github.com/sbadki/applicationsecurity/tree/main&lt;/p&gt;

&lt;p&gt;We are using Bucket4J, it’s a java library to implement the rate limiting which is based of token-bucket algorithm.
Provide following dependency with other required dependencies for spring boot rest API.&lt;/p&gt;

&lt;p&gt;Let’s take an example, if rate limit is set to 10 requests per minute for an API. That means the capacity of the bucket
can set to 10, and we can refill it with 10 tokens per minute.&lt;/p&gt;

&lt;p&gt;If we receive 8 request for first minute, which is less than the bucket capacity for a minute. Then the remaining 2
tokens will be carry forward to next minute in addition to 8 new tokens to full-fill the capacity of bucket to 10 tokens.&lt;/p&gt;

&lt;p&gt;If we receive 10 requests in first 45 seconds itself, then we would need to wait another 15 seconds to serve the requests.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/ratelimit/dependency.JPG&quot; alt=&quot;dependency.JPG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Bucket is built with rate limit of 10 requests per minute, So the API will reject the requests if its already received 
10 requests in a time frame of 1 minute.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/ratelimit/bucket_greedy.JPG&quot; alt=&quot;bucket_greedy.JPG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But what if all the 10 requests came in first 5 seconds which consumed all the tokens leads to spike in the application
suddenly.We can control this limit by applying multiple limits to the bucket. The bucket would serve 10 requests per 
minute but serve 5 requests in 20 seconds time window.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/ratelimit/bucket_inter.JPG&quot; alt=&quot;bucket_inter.JPG&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation:&lt;/h2&gt;

&lt;p&gt;tryConsume will Tries to consume specified number of tokens from the bucket during the specified timeframe.
When it exceeds rate limit then it will reject the request with status code as HTTP - 429 TooManyRequests.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/ratelimit/api_ratelimits.JPG&quot; alt=&quot;api_ratelimits.JPG&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;result&quot;&gt;Result:&lt;/h2&gt;

&lt;p&gt;All the requests after 5 seconds got rejected.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/ratelimit/result.JPG&quot; alt=&quot;result.JPG&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Rate Limiting</summary></entry><entry><title type="html">Insecure Deserialization</title><link href="http://localhost:4000/application/security/blogs/2023/01/30/insecure-deserialization.html" rel="alternate" type="text/html" title="Insecure Deserialization" /><published>2023-01-30T12:28:45+08:00</published><updated>2023-01-30T12:28:45+08:00</updated><id>http://localhost:4000/application/security/blogs/2023/01/30/insecure-deserialization</id><content type="html" xml:base="http://localhost:4000/application/security/blogs/2023/01/30/insecure-deserialization.html">&lt;p&gt;&lt;strong&gt;Insecure deserialization&lt;/strong&gt; is one of the top vulnerability in OWASP top 10 list for 2021. Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application. Successful insecure deserialization attacks could allow an attacker to carry out denial-of-service (DoS) attacks, authentication bypasses and remote code execution attacks.&lt;/p&gt;

&lt;h2 id=&quot;serialization--deserialization&quot;&gt;Serialization &amp;amp; Deserialization:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Serialization&lt;/strong&gt; refers to a process of converting an object into a format which can be persisted to disk (for example saved to a file or a datastore), sent through streams (for example stdout), or sent over a network. The format in which an object is serialized into, can either be binary or structured text (for example XML, JSON YAML…). JSON and XML are two of the most commonly used serialization formats within web applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deserialization&lt;/strong&gt; on the other hand, is the opposite of serialization, that is, transforming serialized data coming from a file, stream or network socket into an object.
There are different libraries or classes for different languages for serialization/deserialization purposes such as in Python - Pickle, PHP - Serialize/Unserialize, Java - ObjectInputStream/ObjectOutputStream and in Javascript - JSON.stringfy()/JSON.parse()&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/serialization.png&quot; alt=&quot;serialization&quot; title=&quot;serialization&quot; /&gt;
Courtesy: Portswigger.net&lt;/p&gt;

&lt;p&gt;Many programming languages support the serialization and deserialization of objects, including Java, PHP, Python, and Ruby. It’s important to understand that safe deserialization of objects is normal practice in software development. The trouble however, starts when deserializing untrusted user input&lt;/p&gt;

&lt;h2 id=&quot;in-secure-deserialization-in-action&quot;&gt;In-Secure deserialization in action:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Insecure deserialization&lt;/strong&gt; is a type of vulnerability that arises when an attacker can manipulate the serialized object and pass harmful data into the application code which cause unintended consequences in the program’s flow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java example:&lt;/strong&gt;
We serialized an Employee object and deserialized it as shown below but how come the name is de-serialised as Jacob!? This is because we are able to override the readObject method of the serialized class.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/employee.png&quot; alt=&quot;JavaExample&quot; title=&quot;JavaExample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hex dump of the serialized employee object shown as below. The email id is referring to Jacob@example.com.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/hex_dump.png&quot; alt=&quot;HexDump&quot; title=&quot;HexDump&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After deserialization the email id is updated to attacker@example.com.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/result.png&quot; alt=&quot;Result&quot; title=&quot;Result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How does this has happened? how does Serialized object is being modified on the fly during Deserialization. This is because Deserialization doesn’t call constructure while re-creating an object from Stream of Bytes, it uses reflection to re-create an object. All the magic is happened because of readObject method overridden in Employee class. These methods are also called as magic methods. Magic methods are a special subset of methods that you do not have to explicitly invoke. Instead, they are invoked automatically whenever a particular event or scenario occurs. Magic methods are a common feature of object-oriented programming in various languages like Ruby, PHP, python, Java etc.&lt;/p&gt;

&lt;p&gt;So, this concludes that the Serialized objects are not secured.&lt;/p&gt;

&lt;p&gt;Attackers can customize deserialization protocol for example, by overriding the readObject() function of the Java Serializable class as shown in below snippet to achieve remote code execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/Vulnerable.png&quot; alt=&quot;VulnerableObject&quot; title=&quot;VulnerableObject&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We are passing a simple command i.e. calc.exec to see the effect. We see that the ClassCastException has occurred while casting a VulnerableObj to Employee object also, the calc.exe also executed. This means any command passed to VulnerableObj will get executed during deserialization of an object. This is just a sample example to show how deserialization can make harm to the system. In reality attacker might do many harm to the system by exploiting this vulnerability.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/serial_vulobj.png&quot; alt=&quot;SerializedVulnerableObject&quot; title=&quot;SerializedVulnerableObject&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gadgets-and-chains-&quot;&gt;Gadgets and Chains :&lt;/h2&gt;

&lt;p&gt;A gadget—as used by Lawrence &amp;amp; Frohoff in their talk Marschalling Pickle at AppSecCali 2015—is a class or function that exists in the application which helps attacker to achieve a particular goal but a gadget may not by itself do anything harmful with user input.
The exploitation strategy is to start with a “kick-off” gadget that’s executed after deserialization and build a chain of instances and method invocations to get to a “sink” gadget that’s able to execute arbitrary code or commands. Once attackers manage to get input to a sink gadget, they can do the maximum damage by performing an arbitrary code execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/gadgetchain.png&quot; alt=&quot;GadgetChain&quot; title=&quot;GadgetChain&quot; /&gt;
Courtesy: https://brandur.org/fragments/gadgets-and-chains&lt;/p&gt;

&lt;p&gt;Attacker needs access to the source code to identify such Gadgets and it’s a tedious task to do it manually. Fortunately, There are tools like &lt;strong&gt;“ysoserial”&lt;/strong&gt; and &lt;strong&gt;“gadget insepctor”&lt;/strong&gt; which helps us to identify suc Gadgets.&lt;/p&gt;

&lt;h2 id=&quot;testing-with-ysoserial&quot;&gt;Testing with ysoserial:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;ysoserial&lt;/strong&gt; is a collection of utilities and property-oriented programming “gadget chains” discovered in common java libraries that can, under the right conditions, exploit Java applications performing unsafe deserialization of objects. The main driver program takes a user-specified command and wraps it in the user-specified gadget chain, then serializes these objects to stdout. When an application with the required gadgets on the classpath unsafely deserializes this data, the chain will automatically be invoked and cause the command to be executed on the application host. (Courtesy: https://github.com/frohoff/ysoserial)&lt;/p&gt;

&lt;p&gt;We could see all these java libraries has gadget chains and if any of these library is happen to found in our applications classpath our application is vulnerable to Insecure deserialization vulnerability. So, today will take an example of commons-collections library and try to run arbitrary command.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/ysoserial.png&quot; alt=&quot;YSoserial&quot; title=&quot;YSoserial&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Usage:&lt;/strong&gt; java -jar ysoserial.jar [payload] ‘[command]’&lt;/p&gt;

&lt;p&gt;The command will create a payload.ser file which will then try to deserialize it with our test class.&lt;/p&gt;

&lt;p&gt;java.exe -jar ysoserial-all.jar CommonsCollections4 ‘calc.exe’ &amp;gt; payload.ser&lt;/p&gt;

&lt;p&gt;Test class to run the gadget chain&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/gadgettest.png&quot; alt=&quot;GadgetChainTest&quot; title=&quot;GadgetChainTest&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We got an error but the arbitrary command ‘calc.exe’ is executed already, likewise an attacker can run any arbitrary code and can cause damage to the system.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/gadgetresult.png&quot; alt=&quot;GadgetChainResult&quot; title=&quot;GadgetChainResult&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mitigation&quot;&gt;Mitigation:&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;• If possible try to avoid serialization, instead use data formats like JSON or XML if there is no language constraints. 
• Use digital signatures to verify the integrity of the data by allowing only authenticated users and processes to have an access to your application. With this validation we can prevent attacks in some extent.
• If can&apos;t avoid and we are forced to implement Serialization due to their hierarchy. We can override deserialize method by throwing an exception. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://sbadki.github.io/applicationsecurity/assets/img/insecure-deserialization/override.png&quot; alt=&quot;Overiride&quot; title=&quot;Overiride&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;• Sanitize user inputs which helps in reduce attack surface of an application. Attackers are able to use objects like cookies to insert malicious information to change user roles. In some cases, they are able to elevate their privileges to administrator rights by using a pre-existing or cached password hash from a previous session to launch DDOS, remote execution attacks.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note: Follow OWASP Insecure Deserialization Cheat Sheet for more details.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Github repo: https://github.com/sbadki/applicationsecurity/tree/main&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="Application" /><category term="security" /><category term="blogs" /><summary type="html">Insecure deserialization is one of the top vulnerability in OWASP top 10 list for 2021. Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application. Successful insecure deserialization attacks could allow an attacker to carry out denial-of-service (DoS) attacks, authentication bypasses and remote code execution attacks.</summary></entry></feed>